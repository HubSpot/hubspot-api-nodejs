export * from '../models/ApiCollectionResponseJoinTimeAndRecordId';
export * from '../models/ApiCollectionResponseRecordListMembershipNoPaging';
export * from '../models/ErrorDetail';
export * from '../models/JoinTimeAndRecordId';
export * from '../models/ListCreateRequest';
export * from '../models/ListCreateResponse';
export * from '../models/ListFetchResponse';
export * from '../models/ListFilterUpdateRequest';
export * from '../models/ListFolderCreateRequest';
export * from '../models/ListFolderCreateResponse';
export * from '../models/ListFolderFetchResponse';
export * from '../models/ListMoveRequest';
export * from '../models/ListSearchRequest';
export * from '../models/ListSearchResponse';
export * from '../models/ListUpdateResponse';
export * from '../models/ListsByIdResponse';
export * from '../models/MembershipChangeRequest';
export * from '../models/MembershipsUpdateResponse';
export * from '../models/ModelError';
export * from '../models/NextPage';
export * from '../models/Paging';
export * from '../models/PreviousPage';
export * from '../models/PublicAbsoluteComparativeTimestampRefineBy';
export * from '../models/PublicAbsoluteRangedTimestampRefineBy';
export * from '../models/PublicAdsSearchFilter';
export * from '../models/PublicAdsTimeFilter';
export * from '../models/PublicAllHistoryRefineBy';
export * from '../models/PublicAllPropertyTypesOperation';
export * from '../models/PublicAndFilterBranch';
export * from '../models/PublicAssociationFilterBranch';
export * from '../models/PublicAssociationInListFilter';
export * from '../models/PublicBatchMigrationMapping';
export * from '../models/PublicBoolPropertyOperation';
export * from '../models/PublicCalendarDatePropertyOperation';
export * from '../models/PublicCampaignInfluencedFilter';
export * from '../models/PublicCommunicationSubscriptionFilter';
export * from '../models/PublicComparativeDatePropertyOperation';
export * from '../models/PublicComparativePropertyUpdatedOperation';
export * from '../models/PublicConstantFilter';
export * from '../models/PublicCtaAnalyticsFilter';
export * from '../models/PublicDatePoint';
export * from '../models/PublicDatePropertyOperation';
export * from '../models/PublicDateTimePropertyOperation';
export * from '../models/PublicEmailEventFilter';
export * from '../models/PublicEmailSubscriptionFilter';
export * from '../models/PublicEnumerationPropertyOperation';
export * from '../models/PublicEventAnalyticsFilter';
export * from '../models/PublicEventFilterMetadata';
export * from '../models/PublicFiscalQuarterReference';
export * from '../models/PublicFiscalYearReference';
export * from '../models/PublicFormSubmissionFilter';
export * from '../models/PublicFormSubmissionFilterCoalescingRefineBy';
export * from '../models/PublicFormSubmissionOnPageFilter';
export * from '../models/PublicInListFilter';
export * from '../models/PublicInListFilterMetadata';
export * from '../models/PublicIndexOffset';
export * from '../models/PublicIndexedTimePoint';
export * from '../models/PublicIndexedTimePointIndexReference';
export * from '../models/PublicIntegrationEventFilter';
export * from '../models/PublicListFolder';
export * from '../models/PublicMigrationMapping';
export * from '../models/PublicMonthReference';
export * from '../models/PublicMultiStringPropertyOperation';
export * from '../models/PublicNotAllFilterBranch';
export * from '../models/PublicNotAnyFilterBranch';
export * from '../models/PublicNowReference';
export * from '../models/PublicNumAssociationsFilter';
export * from '../models/PublicNumOccurrencesRefineBy';
export * from '../models/PublicNumberPropertyOperation';
export * from '../models/PublicObjectList';
export * from '../models/PublicObjectListSearchResult';
export * from '../models/PublicOrFilterBranch';
export * from '../models/PublicPageViewAnalyticsFilter';
export * from '../models/PublicPrivacyAnalyticsFilter';
export * from '../models/PublicPropertyAssociationFilterBranch';
export * from '../models/PublicPropertyAssociationFilterBranchFilterBranchesInner';
export * from '../models/PublicPropertyAssociationFilterBranchFiltersInner';
export * from '../models/PublicPropertyAssociationInListFilter';
export * from '../models/PublicPropertyFilter';
export * from '../models/PublicPropertyReferencedTime';
export * from '../models/PublicQuarterReference';
export * from '../models/PublicRangedDatePropertyOperation';
export * from '../models/PublicRangedNumberPropertyOperation';
export * from '../models/PublicRangedTimeOperation';
export * from '../models/PublicRelativeComparativeTimestampRefineBy';
export * from '../models/PublicRelativeRangedTimestampRefineBy';
export * from '../models/PublicRestrictedFilterBranch';
export * from '../models/PublicRollingDateRangePropertyOperation';
export * from '../models/PublicRollingPropertyUpdatedOperation';
export * from '../models/PublicSetOccurrencesRefineBy';
export * from '../models/PublicStringPropertyOperation';
export * from '../models/PublicSurveyMonkeyFilter';
export * from '../models/PublicSurveyMonkeyValueFilter';
export * from '../models/PublicSurveyMonkeyValueFilterValueComparison';
export * from '../models/PublicTimeOffset';
export * from '../models/PublicTimePointOperation';
export * from '../models/PublicTimePointOperationTimePoint';
export * from '../models/PublicTodayReference';
export * from '../models/PublicUnifiedEventsFilter';
export * from '../models/PublicUnifiedEventsFilterBranch';
export * from '../models/PublicWebinarFilter';
export * from '../models/PublicWeekReference';
export * from '../models/PublicYearReference';
export * from '../models/RecordListMembership';

import { ApiCollectionResponseJoinTimeAndRecordId } from '../models/ApiCollectionResponseJoinTimeAndRecordId';
import { ApiCollectionResponseRecordListMembershipNoPaging } from '../models/ApiCollectionResponseRecordListMembershipNoPaging';
import { ErrorDetail } from '../models/ErrorDetail';
import { JoinTimeAndRecordId } from '../models/JoinTimeAndRecordId';
import { ListCreateRequest } from '../models/ListCreateRequest';
import { ListCreateResponse } from '../models/ListCreateResponse';
import { ListFetchResponse } from '../models/ListFetchResponse';
import { ListFilterUpdateRequest } from '../models/ListFilterUpdateRequest';
import { ListFolderCreateRequest } from '../models/ListFolderCreateRequest';
import { ListFolderCreateResponse } from '../models/ListFolderCreateResponse';
import { ListFolderFetchResponse } from '../models/ListFolderFetchResponse';
import { ListMoveRequest } from '../models/ListMoveRequest';
import { ListSearchRequest } from '../models/ListSearchRequest';
import { ListSearchResponse } from '../models/ListSearchResponse';
import { ListUpdateResponse } from '../models/ListUpdateResponse';
import { ListsByIdResponse } from '../models/ListsByIdResponse';
import { MembershipChangeRequest } from '../models/MembershipChangeRequest';
import { MembershipsUpdateResponse } from '../models/MembershipsUpdateResponse';
import { ModelError } from '../models/ModelError';
import { NextPage } from '../models/NextPage';
import { Paging } from '../models/Paging';
import { PreviousPage } from '../models/PreviousPage';
import { PublicAbsoluteComparativeTimestampRefineBy     } from '../models/PublicAbsoluteComparativeTimestampRefineBy';
import { PublicAbsoluteRangedTimestampRefineBy      } from '../models/PublicAbsoluteRangedTimestampRefineBy';
import { PublicAdsSearchFilter        } from '../models/PublicAdsSearchFilter';
import { PublicAdsTimeFilter    } from '../models/PublicAdsTimeFilter';
import { PublicAllHistoryRefineBy   } from '../models/PublicAllHistoryRefineBy';
import { PublicAllPropertyTypesOperation     } from '../models/PublicAllPropertyTypesOperation';
import { PublicAndFilterBranch      } from '../models/PublicAndFilterBranch';
import { PublicAssociationFilterBranch          } from '../models/PublicAssociationFilterBranch';
import { PublicAssociationInListFilter          } from '../models/PublicAssociationInListFilter';
import { PublicBatchMigrationMapping } from '../models/PublicBatchMigrationMapping';
import { PublicBoolPropertyOperation      } from '../models/PublicBoolPropertyOperation';
import { PublicCalendarDatePropertyOperation       } from '../models/PublicCalendarDatePropertyOperation';
import { PublicCampaignInfluencedFilter    } from '../models/PublicCampaignInfluencedFilter';
import { PublicCommunicationSubscriptionFilter        } from '../models/PublicCommunicationSubscriptionFilter';
import { PublicComparativeDatePropertyOperation       } from '../models/PublicComparativeDatePropertyOperation';
import { PublicComparativePropertyUpdatedOperation       } from '../models/PublicComparativePropertyUpdatedOperation';
import { PublicConstantFilter     } from '../models/PublicConstantFilter';
import { PublicCtaAnalyticsFilter       } from '../models/PublicCtaAnalyticsFilter';
import { PublicDatePoint            } from '../models/PublicDatePoint';
import { PublicDatePropertyOperation        } from '../models/PublicDatePropertyOperation';
import { PublicDateTimePropertyOperation       } from '../models/PublicDateTimePropertyOperation';
import { PublicEmailEventFilter        } from '../models/PublicEmailEventFilter';
import { PublicEmailSubscriptionFilter      } from '../models/PublicEmailSubscriptionFilter';
import { PublicEnumerationPropertyOperation      } from '../models/PublicEnumerationPropertyOperation';
import { PublicEventAnalyticsFilter       } from '../models/PublicEventAnalyticsFilter';
import { PublicEventFilterMetadata } from '../models/PublicEventFilterMetadata';
import { PublicFiscalQuarterReference         } from '../models/PublicFiscalQuarterReference';
import { PublicFiscalYearReference         } from '../models/PublicFiscalYearReference';
import { PublicFormSubmissionFilter      } from '../models/PublicFormSubmissionFilter';
import { PublicFormSubmissionFilterCoalescingRefineByClass } from '../models/PublicFormSubmissionFilterCoalescingRefineBy';
import { PublicFormSubmissionOnPageFilter      } from '../models/PublicFormSubmissionOnPageFilter';
import { PublicInListFilter      } from '../models/PublicInListFilter';
import { PublicInListFilterMetadata } from '../models/PublicInListFilterMetadata';
import { PublicIndexOffset } from '../models/PublicIndexOffset';
import { PublicIndexedTimePoint       } from '../models/PublicIndexedTimePoint';
import { PublicIndexedTimePointIndexReferenceClass } from '../models/PublicIndexedTimePointIndexReference';
import { PublicIntegrationEventFilter     } from '../models/PublicIntegrationEventFilter';
import { PublicListFolder } from '../models/PublicListFolder';
import { PublicMigrationMapping } from '../models/PublicMigrationMapping';
import { PublicMonthReference        } from '../models/PublicMonthReference';
import { PublicMultiStringPropertyOperation      } from '../models/PublicMultiStringPropertyOperation';
import { PublicNotAllFilterBranch      } from '../models/PublicNotAllFilterBranch';
import { PublicNotAnyFilterBranch      } from '../models/PublicNotAnyFilterBranch';
import { PublicNowReference       } from '../models/PublicNowReference';
import { PublicNumAssociationsFilter      } from '../models/PublicNumAssociationsFilter';
import { PublicNumOccurrencesRefineBy     } from '../models/PublicNumOccurrencesRefineBy';
import { PublicNumberPropertyOperation      } from '../models/PublicNumberPropertyOperation';
import { PublicObjectList } from '../models/PublicObjectList';
import { PublicObjectListSearchResult } from '../models/PublicObjectListSearchResult';
import { PublicOrFilterBranch      } from '../models/PublicOrFilterBranch';
import { PublicPageViewAnalyticsFilter        } from '../models/PublicPageViewAnalyticsFilter';
import { PublicPrivacyAnalyticsFilter     } from '../models/PublicPrivacyAnalyticsFilter';
import { PublicPropertyAssociationFilterBranch         } from '../models/PublicPropertyAssociationFilterBranch';
import { PublicPropertyAssociationFilterBranchFilterBranchesInnerClass } from '../models/PublicPropertyAssociationFilterBranchFilterBranchesInner';
import { PublicPropertyAssociationFilterBranchFiltersInnerClass } from '../models/PublicPropertyAssociationFilterBranchFiltersInner';
import { PublicPropertyAssociationInListFilter        } from '../models/PublicPropertyAssociationInListFilter';
import { PublicPropertyFilter     } from '../models/PublicPropertyFilter';
import { PublicPropertyReferencedTime       } from '../models/PublicPropertyReferencedTime';
import { PublicQuarterReference         } from '../models/PublicQuarterReference';
import { PublicRangedDatePropertyOperation        } from '../models/PublicRangedDatePropertyOperation';
import { PublicRangedNumberPropertyOperation       } from '../models/PublicRangedNumberPropertyOperation';
import { PublicRangedTimeOperation           } from '../models/PublicRangedTimeOperation';
import { PublicRelativeComparativeTimestampRefineBy     } from '../models/PublicRelativeComparativeTimestampRefineBy';
import { PublicRelativeRangedTimestampRefineBy      } from '../models/PublicRelativeRangedTimestampRefineBy';
import { PublicRestrictedFilterBranch      } from '../models/PublicRestrictedFilterBranch';
import { PublicRollingDateRangePropertyOperation       } from '../models/PublicRollingDateRangePropertyOperation';
import { PublicRollingPropertyUpdatedOperation      } from '../models/PublicRollingPropertyUpdatedOperation';
import { PublicSetOccurrencesRefineBy    } from '../models/PublicSetOccurrencesRefineBy';
import { PublicStringPropertyOperation      } from '../models/PublicStringPropertyOperation';
import { PublicSurveyMonkeyFilter     } from '../models/PublicSurveyMonkeyFilter';
import { PublicSurveyMonkeyValueFilter         } from '../models/PublicSurveyMonkeyValueFilter';
import { PublicSurveyMonkeyValueFilterValueComparisonClass } from '../models/PublicSurveyMonkeyValueFilterValueComparison';
import { PublicTimeOffset } from '../models/PublicTimeOffset';
import { PublicTimePointOperation         } from '../models/PublicTimePointOperation';
import { PublicTimePointOperationTimePointClass } from '../models/PublicTimePointOperationTimePoint';
import { PublicTodayReference       } from '../models/PublicTodayReference';
import { PublicUnifiedEventsFilter       } from '../models/PublicUnifiedEventsFilter';
import { PublicUnifiedEventsFilterBranch   } from '../models/PublicUnifiedEventsFilterBranch';
import { PublicWebinarFilter     } from '../models/PublicWebinarFilter';
import { PublicWeekReference     } from '../models/PublicWeekReference';
import { PublicYearReference         } from '../models/PublicYearReference';
import { RecordListMembership } from '../models/RecordListMembership';

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

let enumsMap: Set<string> = new Set<string>([
    "PublicAbsoluteComparativeTimestampRefineByTypeEnum",
    "PublicAbsoluteRangedTimestampRefineByTypeEnum",
    "PublicAdsSearchFilterFilterTypeEnum",
    "PublicAdsTimeFilterFilterTypeEnum",
    "PublicAllHistoryRefineByTypeEnum",
    "PublicAllPropertyTypesOperationOperationTypeEnum",
    "PublicAndFilterBranchFilterBranchTypeEnum",
    "PublicAssociationFilterBranchFilterBranchTypeEnum",
    "PublicAssociationInListFilterFilterTypeEnum",
    "PublicBoolPropertyOperationOperationTypeEnum",
    "PublicCalendarDatePropertyOperationFiscalYearStartEnum",
    "PublicCalendarDatePropertyOperationOperationTypeEnum",
    "PublicCampaignInfluencedFilterFilterTypeEnum",
    "PublicCommunicationSubscriptionFilterFilterTypeEnum",
    "PublicComparativeDatePropertyOperationOperationTypeEnum",
    "PublicComparativePropertyUpdatedOperationOperationTypeEnum",
    "PublicConstantFilterFilterTypeEnum",
    "PublicCtaAnalyticsFilterFilterTypeEnum",
    "PublicDatePointTimeTypeEnum",
    "PublicDatePropertyOperationOperationTypeEnum",
    "PublicDateTimePropertyOperationOperationTypeEnum",
    "PublicEmailEventFilterFilterTypeEnum",
    "PublicEmailEventFilterOperatorEnum",
    "PublicEmailSubscriptionFilterFilterTypeEnum",
    "PublicEnumerationPropertyOperationOperationTypeEnum",
    "PublicEventAnalyticsFilterFilterTypeEnum",
    "PublicFiscalQuarterReferenceReferenceTypeEnum",
    "PublicFiscalYearReferenceReferenceTypeEnum",
    "PublicFormSubmissionFilterFilterTypeEnum",
    "PublicFormSubmissionFilterOperatorEnum",
    "PublicFormSubmissionOnPageFilterFilterTypeEnum",
    "PublicFormSubmissionOnPageFilterOperatorEnum",
    "PublicInListFilterFilterTypeEnum",
    "PublicIndexedTimePointTimeTypeEnum",
    "PublicIndexedTimePointIndexReferenceReferenceTypeEnum",
    "PublicIndexedTimePointIndexReferenceDayOfWeekEnum",
    "PublicIntegrationEventFilterFilterTypeEnum",
    "PublicMonthReferenceReferenceTypeEnum",
    "PublicMultiStringPropertyOperationOperationTypeEnum",
    "PublicNotAllFilterBranchFilterBranchTypeEnum",
    "PublicNotAnyFilterBranchFilterBranchTypeEnum",
    "PublicNowReferenceReferenceTypeEnum",
    "PublicNumAssociationsFilterFilterTypeEnum",
    "PublicNumOccurrencesRefineByTypeEnum",
    "PublicNumberPropertyOperationOperationTypeEnum",
    "PublicOrFilterBranchFilterBranchTypeEnum",
    "PublicPageViewAnalyticsFilterFilterTypeEnum",
    "PublicPrivacyAnalyticsFilterFilterTypeEnum",
    "PublicPropertyAssociationFilterBranchFilterBranchTypeEnum",
    "PublicPropertyAssociationFilterBranchFilterBranchesInnerFilterBranchTypeEnum",
    "PublicPropertyAssociationFilterBranchFiltersInnerFilterTypeEnum",
    "PublicPropertyAssociationInListFilterFilterTypeEnum",
    "PublicPropertyFilterFilterTypeEnum",
    "PublicPropertyReferencedTimeTimeTypeEnum",
    "PublicQuarterReferenceReferenceTypeEnum",
    "PublicRangedDatePropertyOperationOperationTypeEnum",
    "PublicRangedNumberPropertyOperationOperationTypeEnum",
    "PublicRangedTimeOperationTypeEnum",
    "PublicRelativeComparativeTimestampRefineByTypeEnum",
    "PublicRelativeRangedTimestampRefineByTypeEnum",
    "PublicRestrictedFilterBranchFilterBranchTypeEnum",
    "PublicRollingDateRangePropertyOperationOperationTypeEnum",
    "PublicRollingPropertyUpdatedOperationOperationTypeEnum",
    "PublicSetOccurrencesRefineByTypeEnum",
    "PublicStringPropertyOperationOperationTypeEnum",
    "PublicSurveyMonkeyFilterFilterTypeEnum",
    "PublicSurveyMonkeyValueFilterFilterTypeEnum",
    "PublicSurveyMonkeyValueFilterValueComparisonFiscalYearStartEnum",
    "PublicTimePointOperationOperationTypeEnum",
    "PublicTimePointOperationTimePointTimeTypeEnum",
    "PublicTodayReferenceReferenceTypeEnum",
    "PublicUnifiedEventsFilterFilterTypeEnum",
    "PublicUnifiedEventsFilterBranchFilterBranchTypeEnum",
    "PublicUnifiedEventsFilterBranchOperatorEnum",
    "PublicWebinarFilterFilterTypeEnum",
    "PublicWeekReferenceDayOfWeekEnum",
    "PublicWeekReferenceReferenceTypeEnum",
    "PublicYearReferenceReferenceTypeEnum",
]);

let typeMap: {[index: string]: any} = {
    "ApiCollectionResponseJoinTimeAndRecordId": ApiCollectionResponseJoinTimeAndRecordId,
    "ApiCollectionResponseRecordListMembershipNoPaging": ApiCollectionResponseRecordListMembershipNoPaging,
    "ErrorDetail": ErrorDetail,
    "JoinTimeAndRecordId": JoinTimeAndRecordId,
    "ListCreateRequest": ListCreateRequest,
    "ListCreateResponse": ListCreateResponse,
    "ListFetchResponse": ListFetchResponse,
    "ListFilterUpdateRequest": ListFilterUpdateRequest,
    "ListFolderCreateRequest": ListFolderCreateRequest,
    "ListFolderCreateResponse": ListFolderCreateResponse,
    "ListFolderFetchResponse": ListFolderFetchResponse,
    "ListMoveRequest": ListMoveRequest,
    "ListSearchRequest": ListSearchRequest,
    "ListSearchResponse": ListSearchResponse,
    "ListUpdateResponse": ListUpdateResponse,
    "ListsByIdResponse": ListsByIdResponse,
    "MembershipChangeRequest": MembershipChangeRequest,
    "MembershipsUpdateResponse": MembershipsUpdateResponse,
    "ModelError": ModelError,
    "NextPage": NextPage,
    "Paging": Paging,
    "PreviousPage": PreviousPage,
    "PublicAbsoluteComparativeTimestampRefineBy": PublicAbsoluteComparativeTimestampRefineBy,
    "PublicAbsoluteRangedTimestampRefineBy": PublicAbsoluteRangedTimestampRefineBy,
    "PublicAdsSearchFilter": PublicAdsSearchFilter,
    "PublicAdsTimeFilter": PublicAdsTimeFilter,
    "PublicAllHistoryRefineBy": PublicAllHistoryRefineBy,
    "PublicAllPropertyTypesOperation": PublicAllPropertyTypesOperation,
    "PublicAndFilterBranch": PublicAndFilterBranch,
    "PublicAssociationFilterBranch": PublicAssociationFilterBranch,
    "PublicAssociationInListFilter": PublicAssociationInListFilter,
    "PublicBatchMigrationMapping": PublicBatchMigrationMapping,
    "PublicBoolPropertyOperation": PublicBoolPropertyOperation,
    "PublicCalendarDatePropertyOperation": PublicCalendarDatePropertyOperation,
    "PublicCampaignInfluencedFilter": PublicCampaignInfluencedFilter,
    "PublicCommunicationSubscriptionFilter": PublicCommunicationSubscriptionFilter,
    "PublicComparativeDatePropertyOperation": PublicComparativeDatePropertyOperation,
    "PublicComparativePropertyUpdatedOperation": PublicComparativePropertyUpdatedOperation,
    "PublicConstantFilter": PublicConstantFilter,
    "PublicCtaAnalyticsFilter": PublicCtaAnalyticsFilter,
    "PublicDatePoint": PublicDatePoint,
    "PublicDatePropertyOperation": PublicDatePropertyOperation,
    "PublicDateTimePropertyOperation": PublicDateTimePropertyOperation,
    "PublicEmailEventFilter": PublicEmailEventFilter,
    "PublicEmailSubscriptionFilter": PublicEmailSubscriptionFilter,
    "PublicEnumerationPropertyOperation": PublicEnumerationPropertyOperation,
    "PublicEventAnalyticsFilter": PublicEventAnalyticsFilter,
    "PublicEventFilterMetadata": PublicEventFilterMetadata,
    "PublicFiscalQuarterReference": PublicFiscalQuarterReference,
    "PublicFiscalYearReference": PublicFiscalYearReference,
    "PublicFormSubmissionFilter": PublicFormSubmissionFilter,
    "PublicFormSubmissionFilterCoalescingRefineBy": PublicFormSubmissionFilterCoalescingRefineByClass,
    "PublicFormSubmissionOnPageFilter": PublicFormSubmissionOnPageFilter,
    "PublicInListFilter": PublicInListFilter,
    "PublicInListFilterMetadata": PublicInListFilterMetadata,
    "PublicIndexOffset": PublicIndexOffset,
    "PublicIndexedTimePoint": PublicIndexedTimePoint,
    "PublicIndexedTimePointIndexReference": PublicIndexedTimePointIndexReferenceClass,
    "PublicIntegrationEventFilter": PublicIntegrationEventFilter,
    "PublicListFolder": PublicListFolder,
    "PublicMigrationMapping": PublicMigrationMapping,
    "PublicMonthReference": PublicMonthReference,
    "PublicMultiStringPropertyOperation": PublicMultiStringPropertyOperation,
    "PublicNotAllFilterBranch": PublicNotAllFilterBranch,
    "PublicNotAnyFilterBranch": PublicNotAnyFilterBranch,
    "PublicNowReference": PublicNowReference,
    "PublicNumAssociationsFilter": PublicNumAssociationsFilter,
    "PublicNumOccurrencesRefineBy": PublicNumOccurrencesRefineBy,
    "PublicNumberPropertyOperation": PublicNumberPropertyOperation,
    "PublicObjectList": PublicObjectList,
    "PublicObjectListSearchResult": PublicObjectListSearchResult,
    "PublicOrFilterBranch": PublicOrFilterBranch,
    "PublicPageViewAnalyticsFilter": PublicPageViewAnalyticsFilter,
    "PublicPrivacyAnalyticsFilter": PublicPrivacyAnalyticsFilter,
    "PublicPropertyAssociationFilterBranch": PublicPropertyAssociationFilterBranch,
    "PublicPropertyAssociationFilterBranchFilterBranchesInner": PublicPropertyAssociationFilterBranchFilterBranchesInnerClass,
    "PublicPropertyAssociationFilterBranchFiltersInner": PublicPropertyAssociationFilterBranchFiltersInnerClass,
    "PublicPropertyAssociationInListFilter": PublicPropertyAssociationInListFilter,
    "PublicPropertyFilter": PublicPropertyFilter,
    "PublicPropertyReferencedTime": PublicPropertyReferencedTime,
    "PublicQuarterReference": PublicQuarterReference,
    "PublicRangedDatePropertyOperation": PublicRangedDatePropertyOperation,
    "PublicRangedNumberPropertyOperation": PublicRangedNumberPropertyOperation,
    "PublicRangedTimeOperation": PublicRangedTimeOperation,
    "PublicRelativeComparativeTimestampRefineBy": PublicRelativeComparativeTimestampRefineBy,
    "PublicRelativeRangedTimestampRefineBy": PublicRelativeRangedTimestampRefineBy,
    "PublicRestrictedFilterBranch": PublicRestrictedFilterBranch,
    "PublicRollingDateRangePropertyOperation": PublicRollingDateRangePropertyOperation,
    "PublicRollingPropertyUpdatedOperation": PublicRollingPropertyUpdatedOperation,
    "PublicSetOccurrencesRefineBy": PublicSetOccurrencesRefineBy,
    "PublicStringPropertyOperation": PublicStringPropertyOperation,
    "PublicSurveyMonkeyFilter": PublicSurveyMonkeyFilter,
    "PublicSurveyMonkeyValueFilter": PublicSurveyMonkeyValueFilter,
    "PublicSurveyMonkeyValueFilterValueComparison": PublicSurveyMonkeyValueFilterValueComparisonClass,
    "PublicTimeOffset": PublicTimeOffset,
    "PublicTimePointOperation": PublicTimePointOperation,
    "PublicTimePointOperationTimePoint": PublicTimePointOperationTimePointClass,
    "PublicTodayReference": PublicTodayReference,
    "PublicUnifiedEventsFilter": PublicUnifiedEventsFilter,
    "PublicUnifiedEventsFilterBranch": PublicUnifiedEventsFilterBranch,
    "PublicWebinarFilter": PublicWebinarFilter,
    "PublicWeekReference": PublicWeekReference,
    "PublicYearReference": PublicYearReference,
    "RecordListMembership": RecordListMembership,
}

type MimeTypeDescriptor = {
    type: string;
    subtype: string;
    subtypeTokens: string[];
};

/**
 * Every mime-type consists of a type, subtype, and optional parameters.
 * The subtype can be composite, including information about the content format.
 * For example: `application/json-patch+json`, `application/merge-patch+json`.
 *
 * This helper transforms a string mime-type into an internal representation.
 * This simplifies the implementation of predicates that in turn define common rules for parsing or stringifying
 * the payload.
 */
const parseMimeType = (mimeType: string): MimeTypeDescriptor => {
    const [type = '', subtype = ''] = mimeType.split('/');
    return {
        type,
        subtype,
        subtypeTokens: subtype.split('+'),
    };
};

type MimeTypePredicate = (mimeType: string) => boolean;

// This factory creates a predicate function that checks a string mime-type against defined rules.
const mimeTypePredicateFactory = (predicate: (descriptor: MimeTypeDescriptor) => boolean): MimeTypePredicate => (mimeType) => predicate(parseMimeType(mimeType));

// Use this factory when you need to define a simple predicate based only on type and, if applicable, subtype.
const mimeTypeSimplePredicateFactory = (type: string, subtype?: string): MimeTypePredicate => mimeTypePredicateFactory((descriptor) => {
    if (descriptor.type !== type) return false;
    if (subtype != null && descriptor.subtype !== subtype) return false;
    return true;
});

// Creating a set of named predicates that will help us determine how to handle different mime-types
const isTextLikeMimeType = mimeTypeSimplePredicateFactory('text');
const isJsonMimeType = mimeTypeSimplePredicateFactory('application', 'json');
const isJsonLikeMimeType = mimeTypePredicateFactory((descriptor) => descriptor.type === 'application' && descriptor.subtypeTokens.some((item) => item === 'json'));
const isOctetStreamMimeType = mimeTypeSimplePredicateFactory('application', 'octet-stream');
const isFormUrlencodedMimeType = mimeTypeSimplePredicateFactory('application', 'x-www-form-urlencoded');

// Defining a list of mime-types in the order of prioritization for handling.
const supportedMimeTypePredicatesWithPriority: MimeTypePredicate[] = [
    isJsonMimeType,
    isJsonLikeMimeType,
    isTextLikeMimeType,
    isOctetStreamMimeType,
    isFormUrlencodedMimeType,
];

const nullableSuffix = " | null";
const optionalSuffix = " | undefined";
const arrayPrefix = "Array<";
const arraySuffix = ">";
const mapPrefix = "{ [key: string]: ";
const mapSuffix = "; }";

export class ObjectSerializer {
    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap.has(expectedType)) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    var discriminatorType = data[discriminatorProperty];
                    let mapping = typeMap[expectedType].mapping;
                    if (mapping != undefined && mapping[discriminatorType]) {
                        return mapping[discriminatorType]; // use the type given in the discriminator
                    } else if(typeMap[discriminatorType]) {
                        return discriminatorType;
                    } else {
                        return expectedType; // discriminator did not map to a type
                    }
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string, format: string): any {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.endsWith(nullableSuffix)) {
            let subType: string = type.slice(0, -nullableSuffix.length); // Type | null => Type
            return ObjectSerializer.serialize(data, subType, format);
        } else if (type.endsWith(optionalSuffix)) {
            let subType: string = type.slice(0, -optionalSuffix.length); // Type | undefined => Type
            return ObjectSerializer.serialize(data, subType, format);
        } else if (type.startsWith(arrayPrefix)) {
            let subType: string = type.slice(arrayPrefix.length, -arraySuffix.length); // Array<Type> => Type
            let transformedData: any[] = [];
            for (let date of data) {
                transformedData.push(ObjectSerializer.serialize(date, subType, format));
            }
            return transformedData;
        } else if (type.startsWith(mapPrefix)) {
            let subType: string = type.slice(mapPrefix.length, -mapSuffix.length); // { [key: string]: Type; } => Type
            let transformedData: { [key: string]: any } = {};
            for (let key in data) {
                transformedData[key] = ObjectSerializer.serialize(
                    data[key],
                    subType,
                    format,
                );
            }
            return transformedData;
        } else if (type === "Date") {
            if (format == "date") {
                let month = data.getMonth()+1
                month = month < 10 ? "0" + month.toString() : month.toString()
                let day = data.getDate();
                day = day < 10 ? "0" + day.toString() : day.toString();

                return data.getFullYear() + "-" + month + "-" + day;
            } else {
                return data.toISOString();
            }
        } else {
            if (enumsMap.has(type)) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // Get the actual type of this object
            type = this.findCorrectType(data, type);

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let attributeType of attributeTypes) {
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type, attributeType.format);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string, format: string): any {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.endsWith(nullableSuffix)) {
            let subType: string = type.slice(0, -nullableSuffix.length); // Type | null => Type
            return ObjectSerializer.deserialize(data, subType, format);
        } else if (type.endsWith(optionalSuffix)) {
            let subType: string = type.slice(0, -optionalSuffix.length); // Type | undefined => Type
            return ObjectSerializer.deserialize(data, subType, format);
        } else if (type.startsWith(arrayPrefix)) {
            let subType: string = type.slice(arrayPrefix.length, -arraySuffix.length); // Array<Type> => Type
            let transformedData: any[] = [];
            for (let date of data) {
                transformedData.push(ObjectSerializer.deserialize(date, subType, format));
            }
            return transformedData;
        } else if (type.startsWith(mapPrefix)) {
            let subType: string = type.slice(mapPrefix.length, -mapSuffix.length); // { [key: string]: Type; } => Type
            let transformedData: { [key: string]: any } = {};
            for (let key in data) {
                transformedData[key] = ObjectSerializer.deserialize(
                    data[key],
                    subType,
                    format,
                );
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap.has(type)) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let attributeType of attributeTypes) {
                let value = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type, attributeType.format);
                if (value !== undefined) {
                    instance[attributeType.name] = value;
                }
            }
            return instance;
        }
    }


    /**
     * Normalize media type
     *
     * We currently do not handle any media types attributes, i.e. anything
     * after a semicolon. All content is assumed to be UTF-8 compatible.
     */
    public static normalizeMediaType(mediaType: string | undefined): string | undefined {
        if (mediaType === undefined) {
            return undefined;
        }
        return (mediaType.split(";")[0] ?? '').trim().toLowerCase();
    }

    /**
     * From a list of possible media types, choose the one we can handle best.
     *
     * The order of the given media types does not have any impact on the choice
     * made.
     */
    public static getPreferredMediaType(mediaTypes: Array<string>): string {
        /** According to OAS 3 we should default to json */
        if (mediaTypes.length === 0) {
            return "application/json";
        }

        const normalMediaTypes = mediaTypes.map(ObjectSerializer.normalizeMediaType);

        for (const predicate of supportedMimeTypePredicatesWithPriority) {
            for (const mediaType of normalMediaTypes) {
                if (mediaType != null && predicate(mediaType)) {
                    return mediaType;
                }
            }
        }

        throw new Error("None of the given media types are supported: " + mediaTypes.join(", "));
    }

    /**
     * Convert data to a string according the given media type
     */
    public static stringify(data: any, mediaType: string): string {
        if (isTextLikeMimeType(mediaType)) {
            return String(data);
        }

        if (isJsonLikeMimeType(mediaType)) {
            return JSON.stringify(data);
        }

        throw new Error("The mediaType " + mediaType + " is not supported by ObjectSerializer.stringify.");
    }

    /**
     * Parse data from a string according to the given media type
     */
    public static parse(rawData: string, mediaType: string | undefined) {
        if (mediaType === undefined) {
            throw new Error("Cannot parse content. No Content-Type defined.");
        }

        if (isTextLikeMimeType(mediaType)) {
            return rawData;
        }

        if (isJsonLikeMimeType(mediaType)) {
            return JSON.parse(rawData);
        }

        throw new Error("The mediaType " + mediaType + " is not supported by ObjectSerializer.parse.");
    }
}
